# 编译流程

```js
// 文件路径: nodemodules/vue/dist/vue.esm-browser.js
function compileToFunction(template, options) {
    if (!isString(template)) { /* 省略 */ }

    // 缓存以提高性能 template为key
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === '#') { /* 省略 */ }
    // compile$1是核心函数
    const { code } = compile$1(template, extend({
        hoistStatic: true,
        onError: onError ,
        onWarn: e => onError(e, true) 
    }, options));
    function onError(err, asWarning = false) { /* 省略 */ }

    const render = (new Function('Vue', code)(runtimeDom));
    render._rc = true;
    return (compileCache[key] = render);
}

// 使用依赖注入的方式
// 通过compileToFunction生成render 函数
registerRuntimeCompiler(compileToFunction);
```

## 下面解析compile$1(baseCompile)函数
```js
function compile$1(template, options = {}) {
    return baseCompile(template, { /* 省略 */ });
}

// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.

/* 
 * 为什么会有 baseCompile 这样的命名呢？因为 compile-core 是编译的核心模块，
 * 接受外部的参数来按照规则完成编译，而 compile-dom 是专门处理浏览器场景下* 的编译，
 * 在这个模块下导出的 compile 函数是入口文件真正接收的编译函数。
 * 而 compile-dom 中的 compile 函数相对 baseCompile 也是更高阶的一个编译器。
 * 例如当 Vue 在 weex 在 iOS 或者 Android 这些 Native App 中工作时，compile-dom 可能会被相关的移动端编译库来取代。
 */
function baseCompile(template, options = {}) {
    /* 省略若干逻辑 */

    // 生成ast抽象语法树
    const ast = isString(template) ? baseParse(template, options) : template;

    // 调用transform对ast节点进行转换处理
    transform(ast, { /* 省略 */ });

    // 调用generate生成code字符串并返回
    return generate(ast, extend({}, options, {
        prefixIdentifiers
    }));
}

```



