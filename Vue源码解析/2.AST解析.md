# AST解析

## baseParse

```js
// 接上一节
const ast = isString(template) ? baseParse(template, options) : template;


function baseParse(content, options = {}) {
    // => content是html字符串, 创建解析的上下文对象, 内涵初始游标信息
    const context = createParserContext(content, options); 
    // context上下文记录游标信息
    /* 初始化数据结构为 => 
     * context = {
     *     options,
     *     column: 1,
     *     line: 1,
     *     offset: 0,
     *     originalSource: content,
     *     source: content,
     *     inPre: false,
     *     inVPre: false,
     *     onWarn: options.onWarn
     * }
     */

    // => 获取初始游标 start = { column, line, offset } = context = { 1, 1, 0 };
    const start = getCursor(context); // 生成记录解析过程的游标信息
    return createRoot( // 生成并返回 root 根节点

        // 关键函数 => next block 
        parseChildren(context, 0 /* DATA */, []),  // 解析子节点，作为 root 根节点的 children 属性  
        getSelection(context, start) // 获取选中的字符串， 当前start === end
        /* 
         * getSelection = {
         *     start,
         *     end,
         *     source: context.originalSource.slice(start.offset, end.offset)
         * }
         */
    );
}
```


```js
function parseChildren(context, mode, ancestors) {
    /* 
     * mode = {
     *     0: DATA,
     *     1: RCDATA,
     *     2: RAWTEXT,
     *     3: CDATA
     * }
     */

    // 获取当前节点的父节点
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;

    // 存储解析后的节点
    const nodes = [];

    while (!isEnd(context, mode, ancestors)) { /* 关键逻辑 => next block */ }

    // Whitespace handling strategy like v2 处理空白字符逻辑，提高输出效率
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) { /* 忽略逻辑 */ }

    // 移除空白字符，返回解析后的节点数组
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}

```


```js
/* parseChildren while循环关键逻辑 */
const s = context.source;
let node = undefined;

// 只有当 TextModes 为 DATA 或 RCDATA 时会继续往下解析。
if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {

    // 判断是否需要解析 Vue 模板语法中的 “Mustache”语法 (双大括号)
    if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        // '{{'
        node = parseInterpolation(context, mode);
    }
    else if (mode === 0 /* DATA */ && s[0] === '<') {
        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
        if (s.length === 1) {
            emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
        }
        else if (s[1] === '!') {
            // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
            if (startsWith(s, '<!--')) {
                node = parseComment(context);
            }
            else if (startsWith(s, '<!DOCTYPE')) {
                // Ignore DOCTYPE by a limitation.
                node = parseBogusComment(context);
            }
            else if (startsWith(s, '<![CDATA[')) {
                if (ns !== 0 /* HTML */) {
                    node = parseCDATA(context, ancestors);
                }
                else {
                    emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                    node = parseBogusComment(context);
                }
            }
            else {
                emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                node = parseBogusComment(context);
            }
        }
        else if (s[1] === '/') {
            // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
            if (s.length === 2) {
                emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
            }
            else if (s[2] === '>') {
                emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                advanceBy(context, 3);
                continue;
            }
            else if (/[a-z]/i.test(s[2])) {
                emitError(context, 23 /* X_INVALID_END_TAG */);
                parseTag(context, 1 /* End */, parent);
                continue;
            }
            else {
                emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                node = parseBogusComment(context);
            }
        }
        else if (/[a-z]/i.test(s[1])) {
            node = parseElement(context, ancestors);
        }
        else if (s[1] === '?') {
            emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
            node = parseBogusComment(context);
        }
        else {
            emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
        }
    }
}
if (!node) {
    node = parseText(context, mode);
}
if (isArray(node)) {
    for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
    }
}
else {
    pushNode(nodes, node);
}

```
